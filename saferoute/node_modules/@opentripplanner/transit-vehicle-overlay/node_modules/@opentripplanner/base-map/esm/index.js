import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React, { Component } from "react";
import PropTypes from "prop-types";
import { LayersControl, Map, Popup, TileLayer } from "react-leaflet";
import utils from "@opentripplanner/core-utils";
import L from "leaflet";
import * as Styled from "./styled";
import callIfValid from "./util";
/**
 * panToOffset will allow you to pan the map and adjust for something like a floating
 * left nav bar, or a page header with an offset center
 *
 * @note adapted from Peter's code: https://gist.github.com/missinglink/7620340
 *
 * @param latlng
 * @param offsetX & offsetY: defaults to [0, 0] ([X, Y] pixel offsets center) a positive x
 * offset to shift the center to the right, and a positive y offset to shift the center to the
 * bottom. Negatives will move to the center point left and top.
 * @param options: pan options https://leafletjs.com/reference.html#pan-options
 * @return return value from a call to https://leafletjs.com/reference.html#map-panto
 */

L.Map.prototype.panToOffset = function (latlng, offsetX, offsetY, options) {
  var x = this.latLngToContainerPoint(latlng).x - (parseInt(offsetX, 10) || 0);
  var y = this.latLngToContainerPoint(latlng).y - (parseInt(offsetY, 10) || 0);
  var point = this.containerPointToLatLng([x, y]);
  /* eslint-disable-next-line no-underscore-dangle */

  return this.setView(point, this._zoom, {
    pan: options
  });
}; // eslint-disable-next-line func-names


L.Evented.addInitHook(function () {
  if (this) this.singleClickTimeout = null;
  this.on("click", this.scheduleSingleClick, this);
  this.on("dblclick dragstart zoomstart", this.cancelSingleClick, this);
});
L.Evented.include({
  cancelSingleClick: function cancelSingleClick() {
    // This timeout is key to workaround an issue where double-click events
    // are fired in this order on some touch browsers: ['click', 'dblclick', 'click']
    // instead of ['click', 'click', 'dblclick']
    // eslint-disable-next-line @typescript-eslint/no-implied-eval
    setTimeout(this.clearSingleClickTimeout.bind(this), 0);
  },
  scheduleSingleClick: function scheduleSingleClick(e) {
    this.clearSingleClickTimeout();
    this.singleClickTimeout = setTimeout( // eslint-disable-next-line @typescript-eslint/no-implied-eval
    this.fireSingleClick.bind(this, e), this.options.singleClickTimeout || 500);
  },
  fireSingleClick: function fireSingleClick(e) {
    // eslint-disable-next-line no-underscore-dangle
    if (!e.originalEvent._stopped) {
      this.fire("singleclick", L.Util.extend(e, {
        type: "singleclick"
      }));
    }
  },
  clearSingleClickTimeout: function clearSingleClickTimeout() {
    if (this.singleClickTimeout !== null) {
      clearTimeout(this.singleClickTimeout);
      this.singleClickTimeout = null;
    }
  }
});
/**
 * The BaseMap component renders a Leaflet map with overlays and other ad-hoc
 * markers that are declared as child elements of the BaseMap element.
 *
 * Overlays are groups of similar React-Leaflet markers, e.g. vehicle location
 * markers, bus stop markers, etc.
 * Overlays are automatically added to the overlay control displayed by the
 * BaseMap. The user uses that control to turn overlays on or off.
 * See the
 * [Two Overlays From TriMet Transit Components](./?path=/story/basemap--with-two-overlays-from-trimet-transit-components)
 * example for more information on overlays.
 */

var BaseMap = /*#__PURE__*/function (_Component) {
  _inherits(BaseMap, _Component);

  var _super = _createSuper(BaseMap);

  function BaseMap(props) {
    var _this;

    _classCallCheck(this, BaseMap);

    _this = _super.call(this, props); // Default active base layer index to zero (first layer).
    // TODO: derive layerIndex from props?

    _this.overlays = [];

    _this.showMapboxWordmark = function () {
      var baseLayers = _this.props.baseLayers;
      var layerIndex = _this.state.layerIndex; // Get current layer and check its URL.

      var activeLayer = baseLayers[layerIndex];
      return activeLayer && activeLayer.url.startsWith("//api.mapbox.com");
    };

    _this.onLeftClick = function (e) {
      var onClick = _this.props.onClick;
      callIfValid(onClick)(e);
    };

    _this.forwardOne = function (eventName, e) {
      // Call the event handler, if implemented, on the layer for which this event applies.
      var layer = _this.overlays.find(function (child) {
        return child.props.name === e.name;
      });

      if (layer) callIfValid(layer[eventName])(e); // Call the event handler on this control's parent element.
      // eslint-disable-next-line react/destructuring-assignment

      callIfValid(_this.props[eventName])(e);
    };

    _this.forwardAll = function (eventName, e) {
      // Call the event handler, if implemented, on each registered overlay.
      _this.overlays.forEach(function (layer) {
        callIfValid(layer[eventName])(e);
      }); // Call the event handler on this control's parent element.
      // eslint-disable-next-line react/destructuring-assignment


      callIfValid(_this.props[eventName])(e);
    };

    _this.handleBaseLayerChange = function (e) {
      var _this$props = _this.props,
          baseLayers = _this$props.baseLayers,
          onBaseLayerChange = _this$props.onBaseLayerChange; // Find layer index

      var index = baseLayers.findIndex(function (l) {
        return l.name === e.name;
      });
      var layer = baseLayers[index]; // Call prop if exists.

      if (typeof onBaseLayerChange === "function") {
        onBaseLayerChange({
          index: index,
          layer: layer
        });
      } // Update active index in state.


      _this.setState({
        layerIndex: index
      });
    };

    _this.handleOverlayAdded = function (e) {
      _this.forwardOne("onOverlayAdded", e);
    };

    _this.handleOverlayRemoved = function (e) {
      _this.forwardOne("onOverlayRemoved", e);
    };

    _this.handleViewportChanged = function (e) {
      _this.forwardAll("onViewportChanged", e);
    };

    _this.registerOverlay = function (overlay) {
      _this.overlays.push(overlay);
    };

    _this.state = {
      layerIndex: 0
    };
    return _this;
  }

  _createClass(BaseMap, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // register single click event
      var lmap = this.refs.map.leafletElement;
      lmap.options.singleClickTimeout = 250;
      lmap.on("singleclick", this.onLeftClick);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {} // remove custom overlays on unmount
    // TODO: Is this needed? It may have something to do with mobile vs desktop views

  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var lmap = this.refs.map.leafletElement;
      lmap.eachLayer(function (layer) {
        // Do not inline, there is a 'this' implied.
        lmap.removeLayer(layer);
      });
    }
    /**
     * Returns whether to show the Mapbox wordmark (if the current layer's URL is
     * a Mapbox url).
     */

  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          baseLayers = _this$props2.baseLayers,
          center = _this$props2.center,
          children = _this$props2.children,
          maxZoom = _this$props2.maxZoom,
          popup = _this$props2.popup,
          onContextMenu = _this$props2.onContextMenu,
          onPopupClosed = _this$props2.onPopupClosed,
          zoom = _this$props2.zoom;
      var layerIndex = this.state.layerIndex; // Separate overlay layers into user-controlled (those with a checkbox in
      // the layer control) and those that are needed by the app (e.g., stop viewer
      // and itinerary overlay).

      var userControlledOverlays = [];
      var fixedOverlays = [];
      React.Children.toArray(children).forEach(function (child) {
        if (child.props.name) {
          var newChild = /*#__PURE__*/React.cloneElement(child, {
            // Inject registerOverlay prop to each custom overlay.
            registerOverlay: _this2.registerOverlay
          });
          userControlledOverlays.push(newChild);
        } else fixedOverlays.push(child);
      });
      return /*#__PURE__*/React.createElement(Map, {
        ref: "map",
        className: "map",
        center: center,
        zoom: zoom,
        maxZoom: maxZoom // onClick={this.onLeftClick}
        // Note: Map-click is handled via single-click plugin, set up in componentDidMount()
        ,
        onContextMenu: onContextMenu,
        onOverlayAdd: this.handleOverlayAdded,
        onBaseLayerChange: this.handleBaseLayerChange,
        onOverlayRemove: this.handleOverlayRemoved,
        onViewportChanged: this.handleViewportChanged
      }, this.showMapboxWordmark() && /*#__PURE__*/React.createElement("a", {
        href: "http://mapbox.com/about/maps",
        className: "mapbox-wordmark",
        target: "_blank noopener noreferrer"
      }, "Mapbox"), /*#__PURE__*/React.createElement(LayersControl, {
        position: "topright"
      }, baseLayers && baseLayers.map(function (layer, i) {
        return /*#__PURE__*/React.createElement(LayersControl.BaseLayer, {
          name: layer.name,
          checked: i === layerIndex,
          key: i
        }, layer.retina ? /*#__PURE__*/React.createElement(TileLayer, {
          url: layer.url,
          attribution: layer.attribution,
          retina: layer.retina,
          maxZoom: layer.maxZoom,
          tileSize: 512,
          zoomOffset: -1,
          detectRetina: layer.detectRetina
        }) : /*#__PURE__*/React.createElement(TileLayer, {
          url: layer.url,
          attribution: layer.attribution,
          maxZoom: layer.maxZoom,
          detectRetina: layer.detectRetina
        }));
      }), userControlledOverlays.map(function (child, i) {
        return /*#__PURE__*/React.createElement(LayersControl.Overlay, {
          key: i,
          name: child.props.name,
          checked: child.props.visible
        }, child);
      })), fixedOverlays, popup && popup.location && popup.contents && /*#__PURE__*/React.createElement(Popup, {
        position: popup.location,
        onClose: onPopupClosed
      }, popup.contents));
    }
  }]);

  return BaseMap;
}(Component);

BaseMap.propTypes = {
  /**
   * Zero, one, or multiple components that extend { MapLayer } from 'react-leaflet'.
   * Children can be overlays or loose markers.
   */
  children: PropTypes.oneOfType([// Ideally, the types below should be MapLayer,
  // however, during type validation in the browser,
  // MapLayer components all seem to resolve to Object.
  PropTypes.node, PropTypes.arrayOf(PropTypes.node)]),

  /**
   * The base (background) layers for the map.
   */
  baseLayers: PropTypes.arrayOf(PropTypes.shape({
    name: PropTypes.string.isRequired,
    url: PropTypes.string.isRequired,
    subdomains: PropTypes.string,
    attribution: PropTypes.string,
    maxZoom: PropTypes.number,
    hasRetinaSupport: PropTypes.bool
  })),

  /**
   * The center of the map, as a [lat, lng] array.
   */
  center: utils.types.latlngType.isRequired,

  /**
   * The maximum zoom level allowed on the map.
   */
  maxZoom: PropTypes.number,

  /**
   * Triggered when the user changes the active base layer.
   * See https://leafletjs.com/reference-1.7.1.html#map-baselayerchange
   */
  onBaseLayerChange: PropTypes.func,

  /**
   * Triggered when the user clicks on the map.
   * See https://leafletjs.com/reference-1.6.0.html#map-click for details.
   */
  onClick: PropTypes.func,

  /**
   * Triggered when the user right-clicks on the map or, on a mobile device, presses the map for a second ("long-press").
   * See https://leafletjs.com/reference-1.6.0.html#map-contextmenu for details.
   */
  onContextMenu: PropTypes.func,

  /**
   * Triggered when the user makes an overlay visible using the map's layers control.
   * See https://leafletjs.com/reference-1.6.0.html#map-overlayadd for details.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  onOverlayAdded: PropTypes.func,

  /**
   * Triggered when the user hides an overlay using the map's layers control.
   * See https://leafletjs.com/reference-1.6.0.html#map-overlayremove for details.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  onOverlayRemoved: PropTypes.func,

  /**
   * Triggered when the user closes the popup (if `popupLocation` and `popupContent` have been set).
   */
  onPopupClosed: PropTypes.func,

  /**
   * Triggered when the user pans the map or changes zoom level.
   * See https://github.com/PaulLeCam/react-leaflet/blob/master/example/components/viewport.js for more details.
   */
  // eslint-disable-next-line react/no-unused-prop-types
  onViewportChanged: PropTypes.func,

  /**
   * The contents and location (in [lat, lng] format) of the popup to display, or null if no popup is displayed.
   */
  popup: PropTypes.shape({
    contents: PropTypes.node.isRequired,
    location: utils.types.latlngType.isRequired
  }),

  /**
   * The zoom level of the map.
   */
  zoom: PropTypes.number
};
BaseMap.defaultProps = {
  children: null,
  baseLayers: [{
    name: "Streets",
    url: "//cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}@2x.png",
    attribution: 'Map tiles: &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>, &copy; <a href="https://carto.com/attributions">CARTO</a>',
    maxZoom: 20 // FIXME?? CartoDB displays characters proportionally too large
    // on regular monitors (1080p or lower) when using the "retina" parameters below.
    // (That does not happen on "retina" displays such as Macbook or mobile phones.)
    // url:
    //  "//cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}{retina}.png",
    // retina: "@2x",
    // detectRetina: true

  }],
  maxZoom: 20,
  onBaseLayerChange: null,
  onClick: null,
  onContextMenu: null,
  onOverlayAdded: null,
  onOverlayRemoved: null,
  onPopupClosed: null,
  onViewportChanged: null,
  popup: null,
  zoom: 13
};
export default BaseMap;
export { Styled };
//# sourceMappingURL=index.js.map