import moment from "moment";
import PropTypes from "prop-types";
import React from "react";
import * as Styled from "../styled";
export default function AlertsBody(_ref) {
  var alerts = _ref.alerts,
      longDateFormat = _ref.longDateFormat,
      timeFormat = _ref.timeFormat,
      AlertIcon = _ref.AlertIcon;
  return /*#__PURE__*/React.createElement(Styled.TransitAlerts, null, alerts.sort(function (a, b) {
    return b.effectiveStartDate - a.effectiveStartDate;
  }).map(function (alert, i) {
    // If alert is effective as of +/- one day, use today, tomorrow, or
    // yesterday with time. Otherwise, use long date format.
    var dateTimeString = moment(alert.effectiveStartDate).calendar(null, {
      sameDay: "".concat(timeFormat, ", [Today]"),
      nextDay: "".concat(timeFormat, ", [Tomorrow]"),
      lastDay: "".concat(timeFormat, ", [Yesterday]"),
      lastWeek: "".concat(longDateFormat),
      sameElse: "".concat(longDateFormat)
    });
    var effectiveDateString = "Effective as of ".concat(dateTimeString);
    return /*#__PURE__*/React.createElement(Styled.TransitAlert, {
      key: i,
      href: alert.alertUrl
    }, /*#__PURE__*/React.createElement(Styled.TransitAlertIconContainer, null, /*#__PURE__*/React.createElement(AlertIcon, null)), alert.alertHeaderText ? /*#__PURE__*/React.createElement(Styled.TransitAlertHeader, null, alert.alertHeaderText) : null, /*#__PURE__*/React.createElement(Styled.TransitAlertBody, null, alert.alertDescriptionText), /*#__PURE__*/React.createElement(Styled.TransitAlertEffectiveDate, null, effectiveDateString));
  }));
}
AlertsBody.propTypes = {
  alerts: PropTypes.arrayOf(PropTypes.shape({})).isRequired,
  longDateFormat: PropTypes.string.isRequired,
  timeFormat: PropTypes.string.isRequired,
  AlertIcon: PropTypes.elementType
};
AlertsBody.defaultProps = {
  AlertIcon: Styled.DefaultAlertBodyIcon
};
//# sourceMappingURL=alerts-body.js.map