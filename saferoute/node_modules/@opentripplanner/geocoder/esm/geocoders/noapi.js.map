{"version":3,"sources":["../../src/geocoders/noapi.ts"],"names":["toCoordinates","fromLatFirstString","Geocoder","NoApiGeocoder","query","parseCoordinateString","text","point","lat","lon","roundGPSDecimal","feature","geometry","coordinates","type","properties","name","geocoderConfig","reverseUseFeatureCollection","Promise","resolve","features","rawGeocodedFeature","string","label","e","number","roundFactor","Math","round"],"mappings":";;;;;;;;;;AAAA,SAASA,aAAT,EAAwBC,kBAAxB,QAAkD,kBAAlD,C,CAEA;AACA;;AAKA,OAAOC,QAAP,MAAqB,qBAArB;AAGA;AACA;AACA;AACA;AACA;AACA;;IACqBC,a;;;;;;;;;;;;;;AACnB;AACF;AACA;AACE,0BAAaC,KAAb,EAAuE;AACrE,aAAO,KAAKC,qBAAL,CAA2BD,KAAK,CAACE,IAAjC,CAAP;AACD;AAED;AACF;AACA;;;;WACE,iBAAQF,KAAR,EAAqE;AAAA;;AACnE,yBAAmBA,KAAK,CAACG,KAAzB;AAAA,UAAMC,GAAN,gBAAMA,GAAN;AAAA,UAAWC,GAAX,gBAAWA,GAAX;AACAD,MAAAA,GAAG,GAAG,KAAKE,eAAL,CAAqBF,GAArB,CAAN;AACAC,MAAAA,GAAG,GAAG,KAAKC,eAAL,CAAqBD,GAArB,CAAN;AACA,UAAME,OAAgB,GAAG;AACvBC,QAAAA,QAAQ,EAAE;AAAEC,UAAAA,WAAW,EAAE,CAACL,GAAD,EAAMC,GAAN,CAAf;AAA2BK,UAAAA,IAAI,EAAE;AAAjC,SADa;AAEvBC,QAAAA,UAAU,EAAE;AAAEC,UAAAA,IAAI,YAAKR,GAAL,eAAaC,GAAb;AAAN,SAFW;AAGvBK,QAAAA,IAAI,EAAE;AAHiB,OAAzB;;AAKA,kCAAI,KAAKG,cAAT,iDAAI,qBAAqBC,2BAAzB,EAAsD;AACpD,eAAOC,OAAO,CAACC,OAAR,CAAgB;AACrBN,UAAAA,IAAI,EAAE,mBADe;AAErBO,UAAAA,QAAQ,EAAE,CAACV,OAAD,CAFW;AAGrBW,UAAAA,kBAAkB,EAAEX;AAHC,SAAhB,CAAP;AAKD;;AAED,aAAOQ,OAAO,CAACC,OAAR,CAAgB;AACrBZ,QAAAA,GAAG,EAAHA,GADqB;AAErBC,QAAAA,GAAG,EAAHA,GAFqB;AAGrBO,QAAAA,IAAI,EAAEL,OAAO,CAACI,UAAR,CAAmBC,IAHJ;AAIrBM,QAAAA,kBAAkB,EAAEX;AAJC,OAAhB,CAAP;AAMD;AAED;AACF;AACA;;;;WACE,gBAAOP,KAAP,EAA2D;AACzD,aAAO,KAAKC,qBAAL,CAA2BD,KAAK,CAACE,IAAjC,CAAP;AACD;AAED;AACF;AACA;AACA;;;;WACE,+BAAsBiB,MAAtB,EAAsE;AACpE,UAAIZ,OAAJ;;AACA,UAAI;AACFA,QAAAA,OAAO,GAAG;AACRC,UAAAA,QAAQ,EAAE;AACRC,YAAAA,WAAW,EAAEb,aAAa,CAACC,kBAAkB,CAACsB,MAAD,CAAnB,CADlB;AAERT,YAAAA,IAAI,EAAE;AAFE,WADF;AAKRC,UAAAA,UAAU,EAAE;AACVS,YAAAA,KAAK,EAAED;AADG;AALJ,SAAV;AASD,OAVD,CAUE,OAAOE,CAAP,EAAU;AACV,eAAON,OAAO,CAACC,OAAR,CAAgB;AAAEC,UAAAA,QAAQ,EAAE,EAAZ;AAAgBP,UAAAA,IAAI,EAAE;AAAtB,SAAhB,CAAP;AACD;;AACD,aAAOK,OAAO,CAACC,OAAR,CAAgB;AAAEC,QAAAA,QAAQ,EAAE,CAACV,OAAD,CAAZ;AAAuBG,QAAAA,IAAI,EAAE;AAA7B,OAAhB,CAAP;AACD;;;WAED,yBAAgBY,MAAhB,EAAwC;AACtC,UAAMC,WAAW,GAAG,MAApB;AACA,aAAOC,IAAI,CAACC,KAAL,CAAWH,MAAM,GAAGC,WAApB,IAAmCA,WAA1C;AACD;;;;EApEwCzB,Q;;SAAtBC,a","sourcesContent":["import { toCoordinates, fromLatFirstString } from \"@conveyal/lonlat\";\n\n// Prettier does not support typescript annotation\n// eslint-disable-next-line prettier/prettier\nimport type { Feature } from \"geojson\";\nimport type { AutocompleteQuery, ReverseQuery, SearchQuery } from \"..\";\nimport type  { MultiGeocoderResponse, SingleOrMultiGeocoderResponse } from \"./types\"\n\nimport Geocoder from \"./abstract-geocoder\";\n\n\n/**\n * An implementation that doesn't use an API for geocoding. Merely allows\n * clicking on the map and finding GPS coordinates by typing them in.\n *\n * @extends Geocoder\n */\nexport default class NoApiGeocoder extends Geocoder {\n  /**\n   * Use coordinate string parser.\n   */\n  autocomplete(query: AutocompleteQuery): Promise<MultiGeocoderResponse> {\n    return this.parseCoordinateString(query.text);\n  }\n\n  /**\n   * Always return the lat/lon.\n   */\n  reverse(query: ReverseQuery): Promise<SingleOrMultiGeocoderResponse> {\n    let { lat, lon } = query.point;\n    lat = this.roundGPSDecimal(lat);\n    lon = this.roundGPSDecimal(lon);\n    const feature: Feature = {\n      geometry: { coordinates: [lat, lon], type: \"Point\" },\n      properties: { name: `${lat}, ${lon}` },\n      type: \"Feature\"\n    };\n    if (this.geocoderConfig?.reverseUseFeatureCollection) {\n      return Promise.resolve({\n        type: \"FeatureCollection\",\n        features: [feature],\n        rawGeocodedFeature: feature\n      });\n    }\n\n    return Promise.resolve({\n      lat,\n      lon,\n      name: feature.properties.name,\n      rawGeocodedFeature: feature\n    })\n  }\n\n  /**\n   * Use coordinate string parser.\n   */\n  search(query: SearchQuery): Promise<MultiGeocoderResponse> {\n    return this.parseCoordinateString(query.text);\n  }\n\n  /**\n   * Attempt to parse the input as a GPS coordinate. If parseable, return a\n   * feature.\n   */\n  parseCoordinateString(string: string): Promise<MultiGeocoderResponse> {\n    let feature;\n    try {\n      feature = {\n        geometry: {\n          coordinates: toCoordinates(fromLatFirstString(string)),\n          type: \"Point\"\n        },\n        properties: {\n          label: string\n        }\n      };\n    } catch (e) {\n      return Promise.resolve({ features: [], type: \"FeatureCollection\" });\n    }\n    return Promise.resolve({ features: [feature], type: \"FeatureCollection\" });\n  }\n\n  roundGPSDecimal(number: number): number {\n    const roundFactor = 100000;\n    return Math.round(number * roundFactor) / roundFactor;\n  }\n}\n"],"file":"noapi.js"}