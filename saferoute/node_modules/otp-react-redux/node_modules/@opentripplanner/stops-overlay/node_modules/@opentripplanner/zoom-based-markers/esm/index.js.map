{"version":3,"sources":["../src/index.js"],"names":["cloneDeep","PropTypes","React","getTransformedSymbol","symbolEntry","symbolTransform","symbolByType","newEntry","Object","entries","forEach","key","originalSymbol","symbol","getSymbolEntry","symbols","zoom","reduce","bestMarker","marker","minZoom","ZoomBasedMarkers","entities","length","transformedEntry","getType","DefaultSymbol","map","entity","EntitySymbol","id","propTypes","arrayOf","shape","string","isRequired","func","number","defaultProps"],"mappings":"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","sourcesContent":["import cloneDeep from \"lodash.clonedeep\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\n\n/**\n * Transforms the symbol and symbols by type from the specified symbolEntry\n * using the specified symbolTransform.\n * TODO: Should this be memoized?\n */\nconst getTransformedSymbol = (symbolEntry, symbolTransform) => {\n  // If no transform function provided, just return symbolEntry.\n  if (typeof symbolTransform !== \"function\") {\n    return symbolEntry;\n  }\n\n  const { symbolByType } = symbolEntry;\n  const newEntry = cloneDeep(symbolEntry);\n\n  if (symbolByType) {\n    // Transform entries in symbolByType.\n    Object.entries(symbolByType).forEach(([key, originalSymbol]) => {\n      newEntry.symbolByType[key] = symbolTransform(originalSymbol);\n    });\n  }\n\n  // Transform the main (default) symbol.\n  newEntry.symbol = symbolTransform(symbolEntry.symbol);\n  return newEntry;\n};\n\n/**\n * Finds the deepest symbol (the symbol associated with the highest minZoom)\n * for the specified symbols and zoom level.\n */\nconst getSymbolEntry = (symbols, zoom) =>\n  symbols.reduce((bestMarker, marker) => {\n    if (zoom >= marker.minZoom) {\n      if (!bestMarker || marker.minZoom > bestMarker.minZoom) {\n        return marker;\n      }\n    }\n    return bestMarker;\n  }, null);\n\n/**\n * A component that renders different components based on zoom level.\n */\nconst ZoomBasedMarkers = ({ entities, symbols, symbolTransform, zoom }) => {\n  if (!entities || !entities.length) return null;\n\n  // Find the deepest symbol for the current zoom level.\n  const symbolEntry = getSymbolEntry(symbols, zoom);\n\n  // With that symbol entry, transform its symbols (if a symbolTransform prop is provided),\n  // and use the transformed symbols to render the entities.\n  if (symbolEntry) {\n    const transformedEntry = getTransformedSymbol(symbolEntry, symbolTransform);\n\n    const { getType, symbol: DefaultSymbol, symbolByType } = transformedEntry;\n    // Note that the result of the transformed symbols can be null (even for DefaultSymbol),\n    // hence the null checks before the return statements below.\n\n    if (symbolByType && getType) {\n      return entities.map(entity => {\n        const EntitySymbol = symbolByType[getType(entity)] || DefaultSymbol;\n        return (\n          EntitySymbol && (\n            <EntitySymbol entity={entity} key={entity.id} zoom={zoom} />\n          )\n        );\n      });\n    }\n\n    if (DefaultSymbol) {\n      return entities.map(entity => (\n        <DefaultSymbol entity={entity} key={entity.id} zoom={zoom} />\n      ));\n    }\n  }\n\n  return null;\n};\n\nZoomBasedMarkers.propTypes = {\n  /**\n   * A list of objects (entities) to be rendered on the map.\n   * Entities must have an id attribute and contain coordinates information for correct placement.\n   */\n  entities: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.string.isRequired\n    })\n  ),\n  /**\n   * A list of symbols that represent the entities at the associated zoom level.\n   * The symbols must be able to obtain the position of the specified entities.\n   * (The list does not need to be sorted.)\n   */\n  // symbols: PropTypes.arrayOf(coreUtils.types.zoomBasedSymbolType).isRequired,\n  /**\n   * An optional function(Component) to transforms components defined in the symbols prop prior to rendering,\n   * in cases you need to wrap symbols or inject children.\n   * The function must return a component that accepts these props: ({ entity, zoom }).\n   * In addition, to inject children, the returned component must explicitly render any applicable children passed to it.\n   */\n  symbolTransform: PropTypes.func,\n  /**\n   * The current zoom level for rendering.\n   */\n  zoom: PropTypes.number.isRequired\n};\n\nZoomBasedMarkers.defaultProps = {\n  entities: null,\n  symbolTransform: null\n};\n\nexport default ZoomBasedMarkers;\n"],"file":"index.js"}