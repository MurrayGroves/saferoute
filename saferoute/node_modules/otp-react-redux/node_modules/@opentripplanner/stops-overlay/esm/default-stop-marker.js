import _extends from "@babel/runtime/helpers/extends";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { Styled as BaseMapStyled } from "@opentripplanner/base-map";
import coreUtils from "@opentripplanner/core-utils";
import FromToLocationPicker from "@opentripplanner/from-to-location-picker";
import PropTypes from "prop-types";
import React, { Component } from "react";
import { CircleMarker, Popup } from "react-leaflet";
import * as S from "./styled";
var _coreUtils$types = coreUtils.types,
    languageConfigType = _coreUtils$types.languageConfigType,
    leafletPathType = _coreUtils$types.leafletPathType,
    stopLayerStopType = _coreUtils$types.stopLayerStopType;

var StopMarker = /*#__PURE__*/function (_Component) {
  _inherits(StopMarker, _Component);

  var _super = _createSuper(StopMarker);

  function StopMarker() {
    var _this;

    _classCallCheck(this, StopMarker);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.onClickView = function () {
      var _this$props = _this.props,
          setViewedStop = _this$props.setViewedStop,
          stop = _this$props.stop;
      setViewedStop({
        stopId: stop.id
      });
    };

    _this.onFromClick = function () {
      _this.setLocation("from");
    };

    _this.onToClick = function () {
      _this.setLocation("to");
    };

    return _this;
  }

  _createClass(StopMarker, [{
    key: "setLocation",
    value: function setLocation(locationType) {
      var _this$props2 = this.props,
          setLocation = _this$props2.setLocation,
          stop = _this$props2.stop;
      var lat = stop.lat,
          lon = stop.lon,
          name = stop.name;
      setLocation({
        location: {
          lat: lat,
          lon: lon,
          name: name
        },
        locationType: locationType
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _geometries$geoJson, _geometries$geoJson$p;

      var _this$props3 = this.props,
          languageConfig = _this$props3.languageConfig,
          leafletPath = _this$props3.leafletPath,
          radius = _this$props3.radius,
          stop = _this$props3.stop;
      var code = stop.code,
          geometries = stop.geometries,
          id = stop.id,
          lat = stop.lat,
          lon = stop.lon,
          name = stop.name;
      var userFacingId = code || id.split(":")[1] || id;
      var extraPathOptions = {}; // We pull the color from the GeoJSON properties instead of directly from
      // the stop object because we only want the stop icon to be route-colored
      // if it is a flex zone, and only flex zone stops have the color inserted
      // into the GeoJSON properties.
      //
      // However, all stops may have a color attribute

      if (geometries !== null && geometries !== void 0 && (_geometries$geoJson = geometries.geoJson) !== null && _geometries$geoJson !== void 0 && (_geometries$geoJson$p = _geometries$geoJson.properties) !== null && _geometries$geoJson$p !== void 0 && _geometries$geoJson$p.color) {
        extraPathOptions.fillColor = geometries.geoJson.properties.color;
      }

      return /*#__PURE__*/React.createElement(CircleMarker
      /* eslint-disable-next-line react/jsx-props-no-spreading */
      , _extends({}, leafletPath, extraPathOptions, {
        center: [lat, lon],
        radius: radius
      }), /*#__PURE__*/React.createElement(Popup, null, /*#__PURE__*/React.createElement(BaseMapStyled.MapOverlayPopup, null, /*#__PURE__*/React.createElement(BaseMapStyled.PopupTitle, null, name), /*#__PURE__*/React.createElement(BaseMapStyled.PopupRow, null, /*#__PURE__*/React.createElement("span", null, /*#__PURE__*/React.createElement("b", null, "Stop ID:"), " ", userFacingId), /*#__PURE__*/React.createElement(S.ViewStopButton, {
        onClick: this.onClickView
      }, languageConfig.stopViewer || "Stop Viewer")), /*#__PURE__*/React.createElement(BaseMapStyled.PopupRow, null, /*#__PURE__*/React.createElement("b", null, "Plan a trip:"), /*#__PURE__*/React.createElement(FromToLocationPicker, {
        onFromClick: this.onFromClick,
        onToClick: this.onToClick
      })))));
    }
  }]);

  return StopMarker;
}(Component);

export { StopMarker as default };
StopMarker.propTypes = {
  languageConfig: languageConfigType.isRequired,
  leafletPath: leafletPathType,
  radius: PropTypes.number,
  setLocation: PropTypes.func.isRequired,
  setViewedStop: PropTypes.func.isRequired,
  stop: stopLayerStopType.isRequired
};
StopMarker.defaultProps = {
  leafletPath: {
    color: "#000",
    fillColor: "#FFF",
    fillOpacity: 1,
    weight: 1
  },
  radius: 5
};
//# sourceMappingURL=default-stop-marker.js.map