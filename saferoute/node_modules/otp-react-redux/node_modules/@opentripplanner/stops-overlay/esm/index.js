import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import utils from "@opentripplanner/core-utils";
import ZoomBasedMarkers from "@opentripplanner/zoom-based-markers";
import PropTypes from "prop-types";
import React from "react";
import { FeatureGroup, GeoJSON, MapLayer, withLeaflet } from "react-leaflet";
import DefaultStopMarker from "./default-stop-marker";
import * as Styled from "./styled";
/**
 * An overlay to view a collection of stops.
 */

var StopsOverlay = /*#__PURE__*/function (_MapLayer) {
  _inherits(StopsOverlay, _MapLayer);

  var _super = _createSuper(StopsOverlay);

  function StopsOverlay() {
    var _this;

    _classCallCheck(this, StopsOverlay);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.refreshStops = function () {
      var _this$props = _this.props,
          leaflet = _this$props.leaflet,
          refreshStops = _this$props.refreshStops,
          symbols = _this$props.symbols; // Force the map to render no symbols if the map zoom level
      // is less than the farthest zoom level at which symbols are defined.

      var minZoomForUpdate = symbols ? symbols.reduce(function (lowestZoom, level) {
        return Math.min(level.minZoom, lowestZoom);
      }, Number.MAX_VALUE) : Number.MAX_VALUE;

      if (leaflet.map.getZoom() < minZoomForUpdate) {
        _this.forceUpdate();

        return;
      }

      var bounds = leaflet.map.getBounds();

      if (!bounds.equals(_this.lastBounds)) {
        setTimeout(function () {
          refreshStops({
            minLat: bounds.getSouth(),
            maxLat: bounds.getNorth(),
            minLon: bounds.getWest(),
            maxLon: bounds.getEast()
          });
          _this.lastBounds = bounds;
        }, 300);
      }
    };

    return _this;
  }

  _createClass(StopsOverlay, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // set up pan/zoom listener
      this.props.leaflet.map.on("moveend", this.refreshStops);
    } // TODO: determine why the default MapLayer componentWillUnmount() method throws an error

  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // Remove the pan/zoom listener set up above.
      this.props.leaflet.map.off("moveend", this.refreshStops);
    }
    /**
     * this method is used for backporting to React 15
     * v16:  return this.props.leaflet;
     * v15:  return this.context;
     */

  }, {
    key: "getLeafletContext",
    value: function getLeafletContext() {
      return this.props.leaflet;
    }
  }, {
    key: "createLeafletElement",
    value: function createLeafletElement() {}
  }, {
    key: "updateLeafletElement",
    value: function updateLeafletElement() {}
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          leaflet = _this$props2.leaflet,
          stops = _this$props2.stops,
          symbols = _this$props2.symbols; // Don't render if no map or no stops are defined.
      // (ZoomBasedMarkers will also not render below the minimum zoom threshold defined in the symbols prop.)

      if (!leaflet || !leaflet.map || !stops || stops.length === 0) {
        return /*#__PURE__*/React.createElement(FeatureGroup, null);
      }

      var zoom = leaflet.map.getZoom();
      var flexGeometries = stops.filter(function (stop) {
        var _stop$geometries, _stop$geometries$geoJ;

        return (stop === null || stop === void 0 ? void 0 : (_stop$geometries = stop.geometries) === null || _stop$geometries === void 0 ? void 0 : (_stop$geometries$geoJ = _stop$geometries.geoJson) === null || _stop$geometries$geoJ === void 0 ? void 0 : _stop$geometries$geoJ.type) === "Polygon";
      }).map(function (stop) {
        // Add first route color to GeoJSON
        var color = stop.color,
            id = stop.id;
        stop.geometries.geoJson.properties = {
          color: color,
          id: id
        };
        return stop.geometries.geoJson;
      });
      return /*#__PURE__*/React.createElement(FeatureGroup, null, /*#__PURE__*/React.createElement(ZoomBasedMarkers, {
        entities: stops,
        symbols: symbols,
        zoom: zoom
      }), flexGeometries.length > 0 && /*#__PURE__*/React.createElement(GeoJSON, {
        data: flexGeometries,
        key: flexGeometries[0].properties.id,
        style: function style(feature) {
          var _feature$geometry;

          var _feature$geometry$pro = feature === null || feature === void 0 ? void 0 : (_feature$geometry = feature.geometry) === null || _feature$geometry === void 0 ? void 0 : _feature$geometry.properties,
              color = _feature$geometry$pro.color;

          return {
            color: color
          };
        }
      }));
    }
  }]);

  return StopsOverlay;
}(MapLayer);

StopsOverlay.propTypes = {
  /** the leaflet reference as obtained from the withLeaflet wrapper */

  /* eslint-disable-next-line react/forbid-prop-types */
  leaflet: PropTypes.object.isRequired,

  /**
   * A callback for refreshing the stops in the event of a map bounds or zoom
   * change event.
   */
  refreshStops: PropTypes.func.isRequired,

  /**
   * The list of stops to create stop markers for.
   */
  stops: PropTypes.arrayOf(utils.types.stopLayerStopType).isRequired,

  /**
   * A list of symbol definitions for the stops to be rendered at specific zoom levels.
   */
  symbols: PropTypes.arrayOf(utils.types.zoomBasedSymbolType).isRequired
};
export default withLeaflet(StopsOverlay);
export { DefaultStopMarker, Styled };
//# sourceMappingURL=index.js.map