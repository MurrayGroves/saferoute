import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import L from "leaflet";
import isEqual from "lodash.isequal";
import PropTypes from "prop-types";
import { MapLayer, withLeaflet } from "react-leaflet";
import Transitive from "transitive-js";
import transitiveStyles from "./transitive-styles";

require("./leaflet-canvas-layer"); // TODO: move to util?


function checkHiPPI(canvas) {
  if (window.devicePixelRatio > 1) {
    var PIXEL_RATIO = 2;
    canvas.style.width = "".concat(canvas.width, "px");
    canvas.style.height = "".concat(canvas.height, "px");
    canvas.width *= PIXEL_RATIO;
    canvas.height *= PIXEL_RATIO;
    var context = canvas.getContext("2d");
    context.scale(PIXEL_RATIO, PIXEL_RATIO);
  }
}
/**
 * Converts OTP mode string to GTFS mode number (copied from transitive-js).
 * TODO: Move to util?
 */


function otpModeToGtfsType(otpMode) {
  switch (otpMode) {
    case "TRAM":
      return 0;

    case "SUBWAY":
      return 1;

    case "RAIL":
      return 2;

    case "BUS":
      return 3;

    case "FERRY":
      return 4;

    case "CABLE_CAR":
      return 5;

    case "GONDOLA":
      return 6;

    case "FUNICULAR":
      return 7;

    default:
      return -1;
  }
}

var zoomFactors = [{
  minScale: 0,
  gridCellSize: 0,
  internalVertexFactor: 0,
  angleConstraint: 5,
  mergeVertexThreshold: 0,
  useGeographicRendering: true
}];
var defaultLabeledModes = ["BUS"];

var TransitiveCanvasOverlay = /*#__PURE__*/function (_MapLayer) {
  _inherits(TransitiveCanvasOverlay, _MapLayer);

  var _super = _createSuper(TransitiveCanvasOverlay);

  function TransitiveCanvasOverlay() {
    _classCallCheck(this, TransitiveCanvasOverlay);

    return _super.apply(this, arguments);
  }

  _createClass(TransitiveCanvasOverlay, [{
    key: "componentDidMount",
    value: // React Lifecycle Methods
    function componentDidMount() {
      var map = this.props.leaflet.map;
      L.canvasLayer().delegate(this) // -- if we do not inherit from L.CanvasLayer  we can setup a delegate to receive events from L.CanvasLayer
      .addTo(map);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      // Check if we received new transitive data
      if (this.transitive && !isEqual(prevProps.transitiveData, this.props.transitiveData)) {
        this.transitive.updateData(this.props.transitiveData);
        if (!this.props.transitiveData) this.transitive.render();else this.updateBoundsAndRender();
      }

      if ( // this block only applies for profile trips where active option changed
      this.props.routingType === "PROFILE" && prevProps.activeItinerary !== this.props.activeItinerary) {
        if (this.props.activeItinerary == null) {
          // no option selected; clear focus
          this.transitive.focusJourney(null);
          this.transitive.render();
        } else if (this.props.transitiveData) {
          this.transitive.focusJourney(this.props.transitiveData.journeys[this.props.activeItinerary].journey_id);
          this.transitive.render();
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.transitive) {
        this.transitive.updateData(null);
        this.transitive.render();
      }
    } // Internal Methods

  }, {
    key: "initTransitive",
    value: function initTransitive(canvas) {
      var _this$props = this.props,
          _this$props$labeledMo = _this$props.labeledModes,
          labeledModes = _this$props$labeledMo === void 0 ? defaultLabeledModes : _this$props$labeledMo,
          leaflet = _this$props.leaflet,
          styles = _this$props.styles,
          transitiveData = _this$props.transitiveData;
      var map = leaflet.map; // Convert OTP modes to GTFS mode numbers.

      var gtfsLabeledModes = labeledModes.map(otpModeToGtfsType); // set up the transitive instance

      var mapBounds = map.getBounds();
      this.transitive = new Transitive({
        data: transitiveData,
        initialBounds: [[mapBounds.getWest(), mapBounds.getSouth()], [mapBounds.getEast(), mapBounds.getNorth()]],
        zoomEnabled: false,
        autoResize: false,
        labeledModes: gtfsLabeledModes,
        styles: _objectSpread(_objectSpread({}, transitiveStyles), styles),
        zoomFactors: zoomFactors,
        display: "canvas",
        canvas: canvas
      });
      checkHiPPI(canvas); // the initial map draw

      this.updateBoundsAndRender();
    }
  }, {
    key: "updateBoundsAndRender",
    value: function updateBoundsAndRender() {
      if (!this.transitive) {
        console.log("WARNING: Transitive object not set in transitive-canvas-overlay");
        return;
      }

      var mapBounds = this.props.leaflet.map.getBounds();
      this.transitive.setDisplayBounds([[mapBounds.getWest(), mapBounds.getSouth()], [mapBounds.getEast(), mapBounds.getNorth()]]);
      this.transitive.render();
    } // Leaflet Layer API Methods

  }, {
    key: "onDrawLayer",
    value: function onDrawLayer(info) {
      if (!this.transitive) this.initTransitive(info.canvas);
      var mapSize = this.props.leaflet.map.getSize();

      if (this.lastMapSize && (mapSize.x !== this.lastMapSize.x || mapSize.y !== this.lastMapSize.y)) {
        var canvas = info.canvas;
        checkHiPPI(canvas);
        this.transitive.display.setDimensions(mapSize.x, mapSize.y);
        this.transitive.display.setCanvas(canvas);
      }

      this.updateBoundsAndRender();
      this.lastMapSize = this.props.leaflet.map.getSize();
    }
  }, {
    key: "createTile",
    value: function createTile() {}
  }, {
    key: "createLeafletElement",
    value: function createLeafletElement() {}
  }, {
    key: "updateLeafletElement",
    value: function updateLeafletElement() {}
  }]);

  return TransitiveCanvasOverlay;
}(MapLayer);

TransitiveCanvasOverlay.propTypes = {
  /**
   * Optional array of OTP modes whose lines should be rendered with a label.
   * Defaults to ['BUS'] if none specified.
   */
  labeledModes: PropTypes.arrayOf(PropTypes.string),

  /**
   * Optional styles to customize the basic defaults for place labels and route segment labels.
   * For examples of applicable style attributes, see
   * https://github.com/conveyal/transitive.js/blob/master/stories/Transitive.stories.js#L47.
   */
  styles: PropTypes.shape({
    labels: PropTypes.shape({}),
    segmentLabels: PropTypes.shape({})
  })
  /**
   * The transitiveData object is assumed to be the result of converting an
   * OpenTripPlanner itinerary result into a transitive-readable format. This is
   * typically done using the @opentripplanner/core-utils/map#itineraryToTransitive
   * function.
   */
  // transitiveData: coreUtils.types.transitiveDataType

};
export default withLeaflet(TransitiveCanvasOverlay);
//# sourceMappingURL=index.js.map