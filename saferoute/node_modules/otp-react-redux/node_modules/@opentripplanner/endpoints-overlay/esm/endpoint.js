import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import flatten from "flat";
import { divIcon } from "leaflet";
import coreUtils from "@opentripplanner/core-utils";
import React, { Component } from "react";
import { FormattedMessage, injectIntl } from "react-intl";
import { Marker, Popup } from "react-leaflet";
import ReactDOMServer from "react-dom/server";
import { Briefcase } from "@styled-icons/fa-solid/Briefcase";
import { Home } from "@styled-icons/fa-solid/Home";
import { MapMarkerAlt } from "@styled-icons/fa-solid/MapMarkerAlt";
import { Sync } from "@styled-icons/fa-solid/Sync";
import { Times } from "@styled-icons/fa-solid/Times";
import * as S from "./styled"; // Load the default messages.

import defaultEnglishMessages from "../i18n/en-US.yml";
// HACK: We should flatten the messages loaded above because
// the YAML loaders behave differently between webpack and our version of jest:
// - the yaml loader for webpack returns a nested object,
// - the yaml loader for jest returns messages with flattened ids.
var defaultMessages = flatten(defaultEnglishMessages);
/**
 * These icons are used to render common icons for user locations. These will
 * only show up in applications that allow saving user locations.
 */

function UserLocationInnerIcon(_ref) {
  var type = _ref.type;

  switch (type) {
    case "briefcase":
      return /*#__PURE__*/React.createElement(Briefcase, {
        size: 12
      });

    case "home":
      return /*#__PURE__*/React.createElement(Home, {
        size: 12
      });

    case "map-marker":
      return /*#__PURE__*/React.createElement(MapMarkerAlt, {
        size: 12
      });

    case "refresh":
      return /*#__PURE__*/React.createElement(Sync, {
        size: 12
      });

    case "times":
      return /*#__PURE__*/React.createElement(Times, {
        size: 12
      });

    default:
      return null;
  }
}
/**
 * Wrapper for icon that includes spacing.
 */


function UserLocationIcon(_ref2) {
  var type = _ref2.type;
  return /*#__PURE__*/React.createElement(S.IconWrapper, null, /*#__PURE__*/React.createElement(UserLocationInnerIcon, {
    type: type
  }));
}

var Endpoint = /*#__PURE__*/function (_Component) {
  _inherits(Endpoint, _Component);

  var _super = _createSuper(Endpoint);

  function Endpoint() {
    var _this;

    _classCallCheck(this, Endpoint);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.rememberAsHome = function () {
      var _this$props = _this.props,
          propsLocation = _this$props.location,
          rememberPlace = _this$props.rememberPlace;

      var location = _objectSpread(_objectSpread({}, propsLocation), {}, {
        icon: "home",
        id: "home",
        type: "home"
      });

      rememberPlace({
        type: "home",
        location: location
      });
    };

    _this.rememberAsWork = function () {
      var _this$props2 = _this.props,
          propsLocation = _this$props2.location,
          rememberPlace = _this$props2.rememberPlace;

      var location = _objectSpread(_objectSpread({}, propsLocation), {}, {
        icon: "briefcase",
        id: "work",
        type: "work"
      });

      rememberPlace({
        type: "work",
        location: location
      });
    };

    _this.forgetHome = function () {
      var forgetPlace = _this.props.forgetPlace;
      forgetPlace("home");
    };

    _this.forgetWork = function () {
      var forgetPlace = _this.props.forgetPlace;
      forgetPlace("work");
    };

    _this.clearLocation = function () {
      var _this$props3 = _this.props,
          clearLocation = _this$props3.clearLocation,
          type = _this$props3.type;
      clearLocation({
        locationType: type
      });
    };

    _this.swapLocation = function () {
      var _this$props4 = _this.props,
          location = _this$props4.location,
          setLocation = _this$props4.setLocation,
          type = _this$props4.type;

      _this.clearLocation();

      var otherType = type === "from" ? "to" : "from";
      setLocation({
        locationType: otherType,
        location: location
      });
    };

    _this.onDragEnd = function (e) {
      var _this$props5 = _this.props,
          intl = _this$props5.intl,
          setLocation = _this$props5.setLocation,
          type = _this$props5.type;

      var _e$target$getLatLng = e.target.getLatLng(),
          lat = _e$target$getLatLng.lat,
          lon = _e$target$getLatLng.lng;

      var location = {
        lat: lat,
        lon: lon,
        name: intl.formatMessage({
          defaultMessage: defaultMessages["otpUi.EndpointsOverlay.coordinates"],
          description: "Formats rendering coordinates for a locale using the correct number separator",
          // FIXME: Combine with the same method at
          // https://github.com/opentripplanner/otp-react-redux/blob/6d5bc90e57843822809b0dff397bad19d66aeb43/lib/components/form/user-settings.js#L34
          // and move this potentially shared message to an appropriate package.
          id: "otpUi.EndpointsOverlay.coordinates"
        }, {
          lat: lat,
          lon: lon
        })
      };
      setLocation({
        locationType: type,
        location: location,
        reverseGeocode: true
      });
    };

    return _this;
  }

  _createClass(Endpoint, [{
    key: "render",
    value: function render() {
      var _this$props6 = this.props,
          location = _this$props6.location,
          locations = _this$props6.locations,
          MapMarkerIcon = _this$props6.MapMarkerIcon,
          showUserSettings = _this$props6.showUserSettings,
          type = _this$props6.type;
      var position = location && location.lat && location.lon ? [location.lat, location.lon] : null;
      if (!position) return null;
      var match = locations.find(function (l) {
        return coreUtils.map.matchLatLon(l, location);
      });
      var isWork = match && match.type === "work";
      var isHome = match && match.type === "home";
      var iconHtml = ReactDOMServer.renderToStaticMarkup( /*#__PURE__*/React.createElement(MapMarkerIcon, {
        location: location,
        type: type
      }));
      var otherType = type === "from" ? "to" : "from";
      var icon = isWork ? "briefcase" : isHome ? "home" : "map-marker";
      return /*#__PURE__*/React.createElement(Marker, {
        draggable: true,
        icon: divIcon({
          html: iconHtml,
          className: ""
        }),
        position: position,
        onDragEnd: this.onDragEnd
      }, showUserSettings && /*#__PURE__*/React.createElement(Popup, null, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("strong", null, /*#__PURE__*/React.createElement(UserLocationIcon, {
        type: icon
      }), location.name), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(S.Button, {
        disabled: isWork,
        onClick: isHome ? this.forgetHome : this.rememberAsHome
      }, isHome ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UserLocationIcon, {
        type: "times"
      }), /*#__PURE__*/React.createElement(FormattedMessage, {
        defaultMessage: defaultMessages["otpUi.EndpointsOverlay.forgetHome"],
        description: "Button text to forget the home location",
        id: "otpUi.EndpointsOverlay.forgetHome"
      })) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UserLocationIcon, {
        type: "home"
      }), /*#__PURE__*/React.createElement(FormattedMessage, {
        defaultMessage: defaultMessages["otpUi.EndpointsOverlay.saveAsHome"],
        description: "Button text to save the location as home location",
        id: "otpUi.EndpointsOverlay.saveAsHome"
      })))), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(S.Button, {
        disabled: isHome,
        onClick: isWork ? this.forgetWork : this.rememberAsWork
      }, isWork ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UserLocationIcon, {
        type: "times"
      }), /*#__PURE__*/React.createElement(FormattedMessage, {
        defaultMessage: defaultMessages["otpUi.EndpointsOverlay.forgetWork"],
        description: "Button text to forget the work location",
        id: "otpUi.EndpointsOverlay.forgetWork"
      })) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UserLocationIcon, {
        type: "briefcase"
      }), /*#__PURE__*/React.createElement(FormattedMessage, {
        defaultMessage: defaultMessages["otpUi.EndpointsOverlay.saveAsWork"],
        description: "Button text to save the location as work location",
        id: "otpUi.EndpointsOverlay.saveAsWork"
      })))), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(S.Button, {
        onClick: this.clearLocation
      }, /*#__PURE__*/React.createElement(UserLocationIcon, {
        type: "times"
      }), /*#__PURE__*/React.createElement(FormattedMessage, {
        defaultMessage: defaultMessages["otpUi.EndpointsOverlay.clearLocation"],
        description: "Button text to clear the from/to location",
        id: "otpUi.EndpointsOverlay.clearLocation",
        values: {
          locationType: type
        }
      }))), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(S.Button, {
        onClick: this.swapLocation
      }, /*#__PURE__*/React.createElement(UserLocationIcon, {
        type: "refresh"
      }), /*#__PURE__*/React.createElement(FormattedMessage, {
        defaultMessage: defaultMessages["otpUi.EndpointsOverlay.swapLocation"],
        description: "Button text to swap the from/to location",
        id: "otpUi.EndpointsOverlay.swapLocation",
        values: {
          locationType: otherType
        }
      }))))));
    }
  }]);

  return Endpoint;
}(Component);

export default injectIntl(Endpoint);
//# sourceMappingURL=endpoint.js.map