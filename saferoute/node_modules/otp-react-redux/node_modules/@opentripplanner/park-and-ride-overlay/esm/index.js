import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { Styled as BaseMapStyled } from "@opentripplanner/base-map";
import FromToLocationPicker from "@opentripplanner/from-to-location-picker";
import PropTypes from "prop-types";
import React from "react";
import { FeatureGroup, MapLayer, Marker, Popup, withLeaflet } from "react-leaflet";
import parkAndRideMarker from "./park-and-ride-marker";

var ParkAndRideOverlay = /*#__PURE__*/function (_MapLayer) {
  _inherits(ParkAndRideOverlay, _MapLayer);

  var _super = _createSuper(ParkAndRideOverlay);

  function ParkAndRideOverlay() {
    _classCallCheck(this, ParkAndRideOverlay);

    return _super.apply(this, arguments);
  }

  _createClass(ParkAndRideOverlay, [{
    key: "componentDidMount",
    value: function componentDidMount() {}
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {}
  }, {
    key: "createLeafletElement",
    value: function createLeafletElement() {}
  }, {
    key: "updateLeafletElement",
    value: function updateLeafletElement() {}
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          keyboard = _this$props.keyboard,
          parkAndRideLocations = _this$props.parkAndRideLocations,
          setLocation = _this$props.setLocation;
      if (!parkAndRideLocations || parkAndRideLocations.length === 0) return /*#__PURE__*/React.createElement(FeatureGroup, null);
      return /*#__PURE__*/React.createElement(FeatureGroup, null, parkAndRideLocations.map(function (location, k) {
        // TODO: extract park-and-ride names from international "Park-And-Ride" string constructs.
        var name = location.name.startsWith("P+R ") ? location.name.substring(4) : location.name;
        return /*#__PURE__*/React.createElement(Marker, {
          icon: parkAndRideMarker,
          key: k,
          keyboard: keyboard,
          position: [location.y, location.x]
        }, /*#__PURE__*/React.createElement(Popup, null, /*#__PURE__*/React.createElement(BaseMapStyled.MapOverlayPopup, null, /*#__PURE__*/React.createElement(BaseMapStyled.PopupTitle, null, name), /*#__PURE__*/React.createElement(BaseMapStyled.PopupRow, null, /*#__PURE__*/React.createElement(FromToLocationPicker, {
          label: true,
          location: {
            lat: location.y,
            lon: location.x,
            name: name
          },
          setLocation: setLocation
        })))));
      }));
    }
  }]);

  return ParkAndRideOverlay;
}(MapLayer);

ParkAndRideOverlay.propTypes = {
  keyboard: PropTypes.bool,
  parkAndRideLocations: PropTypes.arrayOf(PropTypes.shape({
    name: PropTypes.string.isRequired,
    x: PropTypes.number.isRequired,
    y: PropTypes.number.isRequired
  }).isRequired),
  setLocation: PropTypes.func.isRequired
};
ParkAndRideOverlay.defaultProps = {
  keyboard: false
};
export default withLeaflet(ParkAndRideOverlay);
//# sourceMappingURL=index.js.map