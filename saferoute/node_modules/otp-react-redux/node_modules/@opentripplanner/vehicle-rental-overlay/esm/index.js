import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import flatten from "flat";
import { Styled as BaseMapStyled } from "@opentripplanner/base-map";
import coreUtils from "@opentripplanner/core-utils";
import FromToLocationPicker from "@opentripplanner/from-to-location-picker";
import ZoomBasedMarkers from "@opentripplanner/zoom-based-markers";
import PropTypes from "prop-types";
import React from "react";
import { FormattedMessage, injectIntl } from "react-intl";
import { FeatureGroup, MapLayer, Popup, withLeaflet } from "react-leaflet";
import { GenericMarker, HubAndFloatingBike, SharedBikeCircle } from "./DefaultMarkers"; // Load the default messages.

import defaultEnglishMessages from "../i18n/en-US.yml"; // HACK: We should flatten the messages loaded above because
// the YAML loaders behave differently between webpack and our version of jest:
// - the yaml loader for webpack returns a nested object,
// - the yaml loader for jest returns messages with flattened ids.

var defaultMessages = flatten(defaultEnglishMessages);

function makeDefaultGetStationName(intl) {
  return function defaultGetStationName(configCompanies, station) {
    var stationNetworks = coreUtils.itinerary.getCompaniesLabelFromNetworks(station.networks, configCompanies);
    var stationName = station.name || station.id; // If the station name or id is a giant UUID (with more than 3 "-" characters)
    // best not to show that at all and instead use the network name.

    if ((stationName.match(/-/g) || []).length > 3) {
      stationName = stationNetworks;
    }

    if (station.isFloatingBike) {
      stationName = intl.formatMessage({
        defaultMessage: defaultEnglishMessages["otpUi.VehicleRentalOverlay.floatingBike"],
        description: "Popup title for a free-floating bike",
        id: "otpUi.VehicleRentalOverlay.floatingBike"
      }, {
        name: stationName
      });
    } else if (station.isFloatingCar) {
      stationName = intl.formatMessage({
        defaultMessage: defaultEnglishMessages["otpUi.VehicleRentalOverlay.floatingCar"],
        description: "Popup title for a free-floating car",
        id: "otpUi.VehicleRentalOverlay.floatingCar"
      }, {
        company: stationNetworks,
        name: stationName
      });
    } else if (station.isFloatingVehicle) {
      // assumes that all floating vehicles are E-scooters
      stationName = intl.formatMessage({
        defaultMessage: defaultEnglishMessages["otpUi.VehicleRentalOverlay.floatingEScooter"],
        description: "Popup title for a free-floating e-scooter",
        id: "otpUi.VehicleRentalOverlay.floatingEScooter"
      }, {
        company: stationNetworks
      });
    }

    return stationName;
  };
}
/**
 * This vehicle rental overlay can be used to render vehicle rentals of various
 * types. This layer can be configured to show different styles of markers at
 * different zoom levels.
 */


var VehicleRentalOverlay = /*#__PURE__*/function (_MapLayer) {
  _inherits(VehicleRentalOverlay, _MapLayer);

  var _super = _createSuper(VehicleRentalOverlay);

  function VehicleRentalOverlay(props) {
    var _this;

    _classCallCheck(this, VehicleRentalOverlay);

    _this = _super.call(this, props);

    _this.renderSymbolWithPopup = function (_Symbol) {
      var SymbolWrapper = function SymbolWrapper(_ref) {
        var station = _ref.entity,
            zoom = _ref.zoom;
        return /*#__PURE__*/React.createElement(_Symbol, {
          entity: station,
          zoom: zoom
        }, _this.renderPopupForStation(station, station.bikesAvailable !== undefined && !station.isFloatingBike));
      };

      SymbolWrapper.propTypes = {
        // entity: coreUtils.types.stationType.isRequired,
        zoom: PropTypes.number.isRequired
      };
      return SymbolWrapper;
    };

    _this.convertToZoomMarkerSymbols = function (mapSymbols) {
      return mapSymbols.map(function (mapSymbol) {
        // If mapSymbol uses zoomBasedSymbolType, use it as is.
        if (mapSymbol.symbol) {
          return mapSymbol;
        } // Otherwise, convert into zoomBasedType (no support for symbols by type).


        var symbol;

        switch (mapSymbol.type) {
          case "circle":
            symbol = SharedBikeCircle(mapSymbol);
            break;

          case "hubAndFloatingBike":
            symbol = HubAndFloatingBike;
            break;

          default:
            symbol = GenericMarker(mapSymbol);
        }

        return {
          minZoom: mapSymbol.minZoom,
          symbol: symbol
        };
      });
    };

    _this.onOverlayAdded = function () {
      _this.startRefreshing();
    };

    _this.onOverlayRemoved = function () {
      _this.stopRefreshing();
    };

    _this.onViewportChanged = function (viewport) {
      var newZoom = viewport.zoom;

      if (_this.state.zoom !== newZoom) {
        _this.setState({
          zoom: newZoom
        });
      }
    };

    _this.renderPopupForStation = function (station) {
      var stationIsHub = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var _this$props = _this.props,
          configCompanies = _this$props.configCompanies,
          getStationName = _this$props.getStationName,
          intl = _this$props.intl,
          setLocation = _this$props.setLocation;
      var getStationNameFunc = getStationName || makeDefaultGetStationName(intl);
      var stationName = getStationNameFunc(configCompanies, station);
      var location = {
        lat: station.y,
        lon: station.x,
        name: stationName
      };
      return /*#__PURE__*/React.createElement(Popup, null, /*#__PURE__*/React.createElement(BaseMapStyled.MapOverlayPopup, null, /*#__PURE__*/React.createElement(BaseMapStyled.PopupTitle, null, stationName), stationIsHub && /*#__PURE__*/React.createElement(BaseMapStyled.PopupRow, null, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(FormattedMessage, {
        defaultMessage: defaultMessages["otpUi.VehicleRentalOverlay.availableBikes"],
        description: "Label text for the number of bikes available",
        id: "otpUi.VehicleRentalOverlay.availableBikes",
        values: {
          value: station.bikesAvailable
        }
      })), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(FormattedMessage, {
        defaultMessage: defaultMessages["otpUi.VehicleRentalOverlay.availableDocks"],
        description: "Label text for the number of docks available",
        id: "otpUi.VehicleRentalOverlay.availableDocks",
        values: {
          value: station.spacesAvailable
        }
      }))), /*#__PURE__*/React.createElement(BaseMapStyled.PopupRow, null, /*#__PURE__*/React.createElement(FromToLocationPicker, {
        label: true,
        location: location,
        setLocation: setLocation
      }))));
    };

    _this.state = {
      zoom: null
    };
    return _this;
  }
  /**
   * This helper method will be passed to the ZoomBasedMarkers symbolTransform prop.
   * It creates a component that inserts a popup
   * as a child of the specified symbol from the mapSymbols prop.
   */


  _createClass(VehicleRentalOverlay, [{
    key: "createLeafletElement",
    value: function createLeafletElement() {}
  }, {
    key: "updateLeafletElement",
    value: function updateLeafletElement() {}
  }, {
    key: "startRefreshing",
    value: function startRefreshing() {
      var refreshVehicles = this.props.refreshVehicles; // Create the timer only if refreshVehicles is a valid function.

      if (typeof refreshVehicles === "function") {
        // initial station retrieval
        refreshVehicles(); // set up timer to refresh stations periodically

        this.refreshTimer = setInterval(function () {
          refreshVehicles();
        }, 30000); // defaults to every 30 sec. TODO: make this configurable?
      }
    }
  }, {
    key: "stopRefreshing",
    value: function stopRefreshing() {
      if (this.refreshTimer) clearInterval(this.refreshTimer);
    }
    /**
     * When the layer is added (or toggled on, or its visibility becomes true),
     * start refreshing vehicle positions.
     */

  }, {
    key: "componentDidMount",
    value:
    /**
     * Upon mounting, see whether the vehicles should be fetched,
     * and also call the register overlay prop that the
     * @opentripplanner/base-map package has injected to listen to zoom/position changes.
     */
    function componentDidMount() {
      var _this$props2 = this.props,
          leaflet = _this$props2.leaflet,
          registerOverlay = _this$props2.registerOverlay,
          visible = _this$props2.visible;
      this.setState({
        zoom: leaflet.map.getZoom()
      });
      if (visible) this.startRefreshing();

      if (typeof registerOverlay === "function") {
        registerOverlay(this);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopRefreshing();
    }
    /**
     * Render some popup html for a station. This contains custom logic for
     * displaying rental vehicles in the TriMet MOD website that might not be
     * applicable to other regions.
     */

  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          companies = _this$props3.companies,
          leaflet = _this$props3.leaflet,
          mapSymbols = _this$props3.mapSymbols,
          stations = _this$props3.stations;
      var _this$state$zoom = this.state.zoom,
          zoom = _this$state$zoom === void 0 ? leaflet.map.getZoom() : _this$state$zoom; // Render an empty FeatureGroup if the rental vehicles should not be visible
      // on the map. Otherwise previous stations may still be shown due to some
      // react-leaflet internals, maybe? Also, do not return null because that will
      // prevent the overlay from appearing in the layer controls.

      var filteredStations = stations;

      if (companies) {
        filteredStations = stations.filter(function (station) {
          return station.networks.filter(function (value) {
            return companies.includes(value);
          }).length > 0;
        });
      }

      if (!filteredStations || filteredStations.length === 0) {
        return /*#__PURE__*/React.createElement(FeatureGroup, null);
      } // Convert map symbols for this overlay to zoomBasedSymbolType.


      var symbols = this.convertToZoomMarkerSymbols(mapSymbols);
      return /*#__PURE__*/React.createElement(FeatureGroup, null, /*#__PURE__*/React.createElement(ZoomBasedMarkers, {
        entities: filteredStations,
        symbols: symbols,
        symbolTransform: this.renderSymbolWithPopup,
        zoom: zoom
      }));
    }
  }]);

  return VehicleRentalOverlay;
}(MapLayer);

VehicleRentalOverlay.props = {
  /**
   * The entire companies config array.
   */
  // configCompanies: PropTypes.arrayOf(coreUtils.types.companyType.isRequired)
  //   .isRequired,

  /**
   * A list of companies that are applicable to just this instance of the
   * overlay.
   */
  companies: PropTypes.arrayOf(PropTypes.string.isRequired),

  /**
   * An optional custom function to create a string name of a particular vehicle
   * rental station. This function takes two arguments of the configCompanies
   * prop and a vehicle rental station. The function must return a string.
   */
  getStationName: PropTypes.func,

  /**
   * A configuration of what map markers or symbols to show at various
   * zoom levels.
   */
  // mapSymbols: coreUtils.types.vehicleRentalMapOverlaySymbolsType,

  /**
   * If specified, a function that will be triggered every 30 seconds whenever this layer is
   * visible.
   */
  refreshVehicles: PropTypes.func,

  /**
   * A callback for when a user clicks on setting this stop as either the from
   * or to location of a new search.
   *
   * This will be dispatched with the following argument:
   *
   * ```js
   *  {
   *    location: {
   *      lat: number,
   *      lon: number,
   *      name: string
   *    },
   *    locationType: "from" or "to"
   *  }
   * ```
   */
  setLocation: PropTypes.func.isRequired,

  /**
   * A list of the vehicle rental stations specific to this overlay instance.
   */
  // stations: PropTypes.arrayOf(coreUtils.types.stationType),

  /**
   * Whether the overlay is currently visible.
   */
  visible: PropTypes.bool
};
VehicleRentalOverlay.defaultProps = {
  getStationName: null,
  mapSymbols: [{
    zoom: 0,
    symbol: GenericMarker
  }],
  refreshVehicles: null,
  stations: [],
  visible: false
};
export default withLeaflet(injectIntl(VehicleRentalOverlay));
//# sourceMappingURL=index.js.map