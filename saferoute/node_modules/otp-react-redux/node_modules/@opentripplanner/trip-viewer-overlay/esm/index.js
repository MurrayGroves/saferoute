import _extends from "@babel/runtime/helpers/extends";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React from "react";
import { FeatureGroup, MapLayer, Polyline, withLeaflet } from "react-leaflet";
import polyline from "@mapbox/polyline";
/**
 * An overlay that will display the geometry of a trip.
 */

var TripViewerOverlay = /*#__PURE__*/function (_MapLayer) {
  _inherits(TripViewerOverlay, _MapLayer);

  var _super = _createSuper(TripViewerOverlay);

  function TripViewerOverlay() {
    _classCallCheck(this, TripViewerOverlay);

    return _super.apply(this, arguments);
  }

  _createClass(TripViewerOverlay, [{
    key: "componentDidMount",
    value: function componentDidMount() {} // TODO: determine why the default MapLayer componentWillUnmount() method throws an error

  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {}
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var oldGeometry = prevProps.tripData && prevProps.tripData.geometry;
      var newGeometry = this.props.tripData && this.props.tripData.geometry;
      if (oldGeometry === newGeometry || !newGeometry) return;
      var pts = polyline.decode(newGeometry.points);
      this.props.leaflet.map.fitBounds(pts);
    }
  }, {
    key: "createLeafletElement",
    value: function createLeafletElement() {}
  }, {
    key: "updateLeafletElement",
    value: function updateLeafletElement() {}
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          leafletPath = _this$props.leafletPath,
          tripData = _this$props.tripData;
      if (!tripData || !tripData.geometry) return /*#__PURE__*/React.createElement(FeatureGroup, null);
      var pts = polyline.decode(tripData.geometry.points);
      return /*#__PURE__*/React.createElement(FeatureGroup, null, /*#__PURE__*/React.createElement(Polyline, _extends({}, leafletPath, {
        positions: pts
      })));
    }
  }]);

  return TripViewerOverlay;
}(MapLayer);

TripViewerOverlay.propTypes = {
  /**
   * Leaflet path properties to use to style the polyline that represents the
   * trip.
   *
   * See https://leafletjs.com/reference-1.6.0.html#path
   */
  // leafletPath: coreUtils.types.leafletPathType,

  /**
   * This represents data about a trip as obtained from a transit index.
   * Typically a trip has more data than these items, so this is only a list of
   * the properties that this component actually uses.
   */
  // tripData: PropTypes.shape({
  // geometry: coreUtils.types.encodedPolylineType
  // })
};
TripViewerOverlay.defaultProps = {
  leafletPath: {
    color: "#00bfff",
    opacity: 0.6,
    weight: 8
  }
};
export default withLeaflet(TripViewerOverlay);
//# sourceMappingURL=index.js.map