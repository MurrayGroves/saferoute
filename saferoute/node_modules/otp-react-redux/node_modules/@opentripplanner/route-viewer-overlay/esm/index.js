import _extends from "@babel/runtime/helpers/extends";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import PropTypes from "prop-types";
import React from "react";
import { FeatureGroup, MapLayer, Polyline, withLeaflet } from "react-leaflet";
import polyline from "@mapbox/polyline";
import pointInPolygon from "point-in-polygon"; // helper fn to check if geometry has been populated for all patterns in route

var isGeomComplete = function isGeomComplete(routeData) {
  return routeData && routeData.patterns && Object.values(routeData.patterns).every(function (ptn) {
    return typeof (ptn === null || ptn === void 0 ? void 0 : ptn.geometry) !== "undefined";
  });
};
/**
 * helper function that removes all points from array of points that are
 * within flex zones defined in an array of stops
 * @param {*} stops   OTP stops response
 * @param {*} points  Array of coordinates to clip
 * @returns           The array of coordinates without coordinates within the stops
 */


var removePointsInFlexZone = function removePointsInFlexZone(stops, points) {
  // First, go through all stops to find flex zones
  var bboxes = (stops === null || stops === void 0 ? void 0 : stops.map(function (stop) {
    var _stop$geometries, _stop$geometries$geoJ, _stop$geometries$geoJ2;

    if (((_stop$geometries = stop.geometries) === null || _stop$geometries === void 0 ? void 0 : (_stop$geometries$geoJ = _stop$geometries.geoJson) === null || _stop$geometries$geoJ === void 0 ? void 0 : _stop$geometries$geoJ.type) !== "Polygon") {
      return null;
    }

    return ((_stop$geometries$geoJ2 = stop.geometries.geoJson.coordinates) === null || _stop$geometries$geoJ2 === void 0 ? void 0 : _stop$geometries$geoJ2[0]) || null;
  }) // Remove the null entries
  .filter(function (bbox) {
    return !!bbox;
  })) || []; // Points we keep can't be in any of the flex zones

  return points.filter(function (point) {
    var _point = _slicedToArray(point, 2),
        y = _point[0],
        x = _point[1];

    return bboxes.every(function (bbox) {
      return !pointInPolygon([x, y], bbox);
    });
  });
};
/**
 * An overlay that will display all polylines of the patterns of a route.
 */


var RouteViewerOverlay = /*#__PURE__*/function (_MapLayer) {
  _inherits(RouteViewerOverlay, _MapLayer);

  var _super = _createSuper(RouteViewerOverlay);

  function RouteViewerOverlay() {
    _classCallCheck(this, RouteViewerOverlay);

    return _super.apply(this, arguments);
  }

  _createClass(RouteViewerOverlay, [{
    key: "componentDidMount",
    value: function componentDidMount() {} // TODO: determine why the default MapLayer componentWillUnmount() method throws an error

  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {}
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      // if pattern geometry updated, update the map points
      if (this.props.allowMapCentering && isGeomComplete(this.props.routeData)) {
        var allPoints = Object.values(this.props.routeData.patterns).reduce(function (acc, ptn) {
          return acc.concat(polyline.decode(ptn.geometry.points));
        }, []);

        if (allPoints.length > 0 && this.props.leaflet.map) {
          this.props.leaflet.map.fitBounds(allPoints);

          if (this.props.mapCenterCallback) {
            this.props.mapCenterCallback();
          }
        }
      }
    }
  }, {
    key: "createLeafletElement",
    value: function createLeafletElement() {}
  }, {
    key: "updateLeafletElement",
    value: function updateLeafletElement() {}
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          clipToPatternStops = _this$props.clipToPatternStops,
          path = _this$props.path,
          routeData = _this$props.routeData;
      if (!routeData || !routeData.patterns) return /*#__PURE__*/React.createElement(FeatureGroup, null);
      var routeColor = routeData.color ? "#".concat(routeData.color) : path.color;
      var segments = [];
      Object.values(routeData.patterns).forEach(function (pattern) {
        if (!(pattern !== null && pattern !== void 0 && pattern.geometry)) return;
        var pts = polyline.decode(pattern.geometry.points);
        var clippedPts = clipToPatternStops ? removePointsInFlexZone(pattern === null || pattern === void 0 ? void 0 : pattern.stops, pts) : pts;
        segments.push( /*#__PURE__*/React.createElement(Polyline
        /* eslint-disable-next-line react/jsx-props-no-spreading */
        , _extends({}, path, {
          color: routeColor,
          key: pattern.id,
          positions: clippedPts
        })));
      });
      return segments.length > 0 ? /*#__PURE__*/React.createElement(FeatureGroup, null, /*#__PURE__*/React.createElement("div", null, segments)) : /*#__PURE__*/React.createElement(FeatureGroup, null);
    }
  }]);

  return RouteViewerOverlay;
}(MapLayer);

RouteViewerOverlay.propTypes = {
  /**
   * This boolean value allows disabling of map centering and panning.
   */
  allowMapCentering: PropTypes.bool,

  /**
   * If pattern stops contain polygons, we can request that the routes are not drawn
   * inside of these polygons by setting this prop to true. If true, the layer will
   * check every zone of every stop in a pattern before drawing the route for that pattern
   * and only draw the route outside of the polygon.
   */
  clipToPatternStops: PropTypes.bool,

  /**
   * This method is called whenever the bounds are updated to fit a route
   */
  mapCenterCallback: PropTypes.func,

  /**
   * Leaflet path properties to use to style each polyline that represents a
   * pattern of the route. Only a few of the items are actually used.
   *
   * See https://leafletjs.com/reference-1.6.0.html#path
   */
  // Typescript TODO: restore correct type ?
  // path: coreUtils.types.leafletPathType,

  /**
   * This represents data about a route as obtained from a transit index.
   * Typically a route has more data than these items, so this is only a list of
   * the properties that this component actually uses.
   */
  routeData: PropTypes.shape({
    color: PropTypes.string,
    patterns: PropTypes.objectOf(PropTypes.shape({
      // Typescript TODO: restore correct type ?
      // geometry: coreUtils.types.encodedPolylineType,
      id: PropTypes.string.isRequired,
      stops: PropTypes.arrayOf(PropTypes.shape({
        geometries: PropTypes.objectOf({
          geoJson: PropTypes.objectOf({
            coordinates: PropTypes.arrayOf(PropTypes.number),
            type: PropTypes.string
          })
        })
      }))
    }).isRequired)
  })
};
RouteViewerOverlay.defaultProps = {
  allowMapCentering: true,
  path: {
    color: "#00bfff",
    opacity: 1,
    weight: 4
  }
};
export default withLeaflet(RouteViewerOverlay);
//# sourceMappingURL=index.js.map